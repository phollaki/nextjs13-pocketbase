# NextJS 13

## Routing

New routing works with App directory. Instead of pages directory now we have an ./app directory in the root folder, that contains all our diferent route pages.

app/page.tsx -> index page  -> http://localhost:3000

#### Folder based routes
app/about/page.tsx -> about page -> http://localhost:3000/about

#### Dynamic routes
app/articles/[slug]/page.tsx -> dynamic article page by slug -> http://localhost:3000/articles/[slug]

#### Ignored files by routing system
(group)

app/(marketing) <- ignored by routing system, cannot access by http://localhost:3000/marketing


### Reserved Files
- page.tsx
- layout.tsx
- loading.tsx
- error.tsx
- template.tsx
- head.tsx

<img src="./markdown-next13/assets/reserved-files.png"/>


#### Use new build tool Turbopack
Webpack written in Rust - Currently in Alpha

![Alt text](./markdown-next13/image.png)

![Alt text](./markdown-next13/image-1.png)


### Layouts

By default our application has a root layout in app folder -> app/layout.tsx. 

Layouts can be nested:
<img width="310" alt="image" src="https://github.com/phollaki/nextjs13-pocketbase/assets/60651308/1ac8e0d0-c0a9-4f00-9fb8-ab39e7df0b97">

Layouts can be used for data fetching, which can be usefull if we use the same data on multiple routes.

Layouts works like a page, they look all similar to pages but layouts does not re-render. In some cases it can be problematic. To handle that we can use a template.tsx file instead of a layout file. It works in the same way BUT it re-mount the component on each navigation.

Create a layout.tsx file, it should contain navbar & footer.


We can fetch in layouts too. Layouts are server components by default.

```js
import './globals.css'
import type { Metadata } from 'next'
import { Inter } from 'next/font/google'

const inter = Inter({ subsets: ['latin'] })

export const metadata: Metadata = {
  title: 'Create Next App',
  description: 'Generated by create next app',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  )
}
```

Layouts can be nested:
![Alt text](./markdown-next13/image-2.png)


### Route with Link component

```js
<Link href="/notes">Notes</Link>
```

Link component is basically an <a html tag with a more sophisticated way of routing. It does not make a full page reload. In addition we can route with useRouter next/router hook.

```js
import { useRouter } from 'next/router)
router = useRouter()

const someEvent = () => {
  router.push('/something')
  router.back()
  router.reload()
}
```


Dynamic routes needs a param, like id. [id]. We can get the params from a nextjs Page props. 
```js
export default function Home({params}):Props {
  const res = await fetch(`https://.../api/${params.id}`)
}
```

Routes can have many segments, if we need a catch-all route we should use ... spread syntax [...id]

### Route groups
To create a route group wrap route folder into a parenthesis. This url does not effect url structure.
<img width="403" alt="image" src="https://github.com/phollaki/nextjs13-pocketbase/assets/60651308/ca005aec-bd4b-4da3-b848-8f7ff2c25232">

### Parralell routing
@pro
@basic

Create a named slot that can access in a parent layout.
<img width="652" alt="image" src="https://github.com/phollaki/nextjs13-pocketbase/assets/60651308/75370ab3-032e-4789-b806-dd9d72c76dcd">

### Intercepting routes
This route will render the default page for SSR(server side rendering) but then a totally different page for CSR(client side rendering).
<img width="695" alt="image" src="https://github.com/phollaki/nextjs13-pocketbase/assets/60651308/12ddf91d-70af-42c8-992f-5d5563fa25fe">
<img width="632" alt="image" src="https://github.com/phollaki/nextjs13-pocketbase/assets/60651308/6fa5e983-da79-4e90-a4e9-28d1dd741380">



First, create a Link that goes to /notes route.

```js
import Link from 'next/link'

export default function Home() {
  return (
    <main className="flex min-h-screen flex-col items-center justify-between p-24">
      <div className="z-10 w-full max-w-5xl items-center justify-between font-mono text-sm lg:flex">
        <Link href="/notes">Notes</Link>
      </div>
    </main>
  )
}
```

Second, create a notes folder in the app directory -> app/notes
Then create a page.tsx in the notes folder.

We can name it how we like forexample NotesPage. It can be an async arrow or normal function.

```js
import React from 'react'

export const NotesPage = async () => {
  return (
    <div>
      <h1>Notes</h1>
    </div>
  )
}
```

```js
export default async function NotesPage = () => {
  return (
    <div>
      <h1>Notes</h1>
    </div>
  )
}
```

### Server - Client components

Nextjs components are server components by default. Which means they get rendered on the server, we can do data fetching on the server & Render result on Client components || Server components

```js
import React from 'react'

const getNotes = async () => {
  const res = await fetch('http://127.0.0.1:8090/api/collections/notes/records');
  const data = await res.json();
  return data?.items as any[];
}

const NotesPage = async () => {
  const notes = await getNotes()

  return (
    <div className=''>
      <h1>Notes</h1>
      {JSON.stringify(notes)}
    </div>
  )
}

export default NotesPage
```

To paginate with pocketbase

```js
const getNotes = async () => {
  const res = await fetch('http://127.0.0.1:8090/api/collections/notes/records?page=1&perPage=30');
  const data = await res.json();
  return data?.items as any[];
}
```

To render out the Notes:

```js
const NotesPage = async () => {
  const notes = await getNotes()

  return (
    <div className=''>
      <h1>Notes</h1>
      <div>
        {notes?.map((note)=>{
          return <Note key={note.id} note={note} />
        })}
      </div>
    </div>
  )
}

const Note = ({note}: any) => {
  const {id, title, content, created} = note || {}

  return (
    <Link href={`/notes/${id}`}>
      <p>{id}</p>
      <h2>{title}</h2>
      <p>{content}</p>
      <p>{created}</p>
    </Link>
  )
}
```

On /notes page:
![Alt text](./markdown-next13/image-3.png)


### <b style="color:red;">!Important to Know!</b>

Next will automatically cache this page because the route segment is not dynamic.
In other words, it treated like a static page. What we can do about it, is to change cache by adding 'no store' in fetch options.

Now it will refetch the items from the server on every request.

Its roughly the equivalent of getServerSideProps.

```js
const res = await fetch('http://127.0.0.1:8090/api/collections/notes/records?page=1&perPage=30',{
  cache: 'no-store'
});
```

We don't need to use fetch here, we can use PocketBase built in sdk.
```js
import PocketBase from 'pocketbase'

const getNotes = async () => {
  const db = new PocketBase('http://127.0.0.1:8090')
  const data = await db.collection('notes').getList()
  return data?.items as any[]
}
```

But now how do we change the caching behaviour?

Next 13 also has a varity of variables that we can export from the page to change behaviours of caching or runtime.

```js
export const dynamic = 'auto',
dynamicParams = true,
revalidate = 0,
fetchCache = 'auto',
runtime = 'nodejs',
preferredRegion = 'auto'
```


## Dynamic routes

Next step to create a dynamic route for the specific note by ID.

Create an [id] folder under app/notes, then create a page.tsx inside.

It will also be an async function

```js
const NotePage = async () => {

  return (
    <div>page</div>
  )
}

export default NotePage
```

Lets use the fetch function again to fetch note by id.

```js
const res = await fetch(`http://127.0.0.1:8090/api/collections/notes/records/${noteId}?page=1&perPage=30`,{
  next: {
    revalidate: 10 // Incremental Static Regeneration: https://nextjs.org/docs/pages/building-your-application/data-fetching/incremental-static-regeneration
  }
});
```

### ISR - Incremental Static Regeneration

- Any requests to the page after the initial request and before 10 seconds are also cached and instantaneous.
- After the 10-second window, the next request will still show the cached (stale) page
- Next.js triggers a regeneration of the page in the background.
- Once the page generates successfully, Next.js will invalidate the cache and show the updated page. If the background regeneration fails, the old page would still be unaltered.


## Prerender a page

If we want to prerender a page, then use generateStaticParams. Its an equivalent function of getStaticPaths & previous versions of Next.

![Alt text](./markdown-next13/image-4.png)


## Loading State

With the new app route system we can create a reserved file loading.tsx that handles loading for us.

app/notes/[id]/loading.tsx

```js
import React from 'react'

const NoteLoadingPage = () => {
  return (
    <div className="animate-pulse flex justify-center items-center">
        <p className="text-3xl">Loading . . .</p>
    </div>
  )
}

export default NoteLoadingPage
```

## Error state

Same with Error

```js
'use client' // Error components must be Client Components

import { useEffect } from 'react'

export default function Error({
  error,
  reset,
}: {
  error?: Error
  reset?: () => void
}) {
  useEffect(() => {
    // Log the error to an error reporting service
    console.error(error)
  }, [error])

  return (
    <div>
      <h2>Something went wrong! {error?.message}</h2>
      <button
        onClick={
          // Attempt to recover by trying to re-render the segment
          () => reset?.()
        }
      >
        Try again
      </button>
    </div>
  )
}
```
![Alt text](./markdown-next13/image-5.png)


## Mutate data with Next Client components

So far we looked at data fetching.

For mutating data, create a client component.

in app/notes directory create a CreateNode component for the form

Make it a client component with 'use client' flag so we can send requests inside the component.

```js
'use client'
import { useRouter } from 'next/navigation'
import React, { useState } from 'react'

export default function CreateNote() {
  const [title, setTitle] = useState('')
  const [content, setContent] = useState('')

  return (
    <form className='space-y-5 flex flex-col w-96' onSubmit={create}>
      <h1 className='text-4xl font-bold text-yellow-600 drop-shadow-lg shadow-blue-500'>Create a new Notes</h1>
      <input
        className='text-black'
        type='text'
        placeholder='Title'
        value={title}
        onChange={(e)=>setTitle(e.target.value)}
      />
      <input
        className='text-black'
        type='text'
        placeholder='Content'
        value={content}
        onChange={(e)=>setContent(e.target.value)}
      />
      <button disabled={!title || !content} className="p-3 disabled:bg-gray-400 rounded-full text-black bg-yellow-600 hover:bg-yellow-500">Submit</button>
    </form>
  )
}
```

Then create a fetch request to mutate notes collection on PocketBase.
Note: use next useRouter from next/navigation then refresh the page after a note creation.

```js
  const router = useRouter()

  const create = async() => {
    await fetch('http://127.0.0.1:8090/api/collections/notes/records', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        title,
        content
      })
    });

    setTitle('')
    setContent('')

    router.refresh()
  }
```

## Route handlers

Most of our routes in nextjs has a page.tsx file to render some component on the client, but if we need only api calls we can create a route handler by create a route.ts file in the route folder.

Route is a lowest level primitive that can not used in the same directory with pages.tsx

That file can export 1 or more functions with name - HTTP request methods.

export a default function named:
- GET
- POST
- DELETE
- PUT
- PATCH
- HEAD
- OPTIONS

Each endpoint gets a request object and have to return a response. 
<img width="398" alt="image" src="https://github.com/phollaki/nextjs13-pocketbase/assets/60651308/2ec48ef7-e0e1-450a-8c47-53c95ead3930">

### Next response extended api
Next optionally extends request and response apis. Which can make easier our life if we want to response json().
<img width="488" alt="image" src="https://github.com/phollaki/nextjs13-pocketbase/assets/60651308/cfd1372a-f35a-42de-8a37-adfe150f294d">

API routes always run on server side, by default on nodejs runtime. We can change runtime with 
```js
export const runtime = 'edge'
```

## SEO
Server side components are useful for SEO because they build and rendered on a server so crawlers can detect our content easier & faster.
By default all NextJS component server component.

If we want to use interactivity on the page, like user click event or any useState, useEffect hook, we need to flag our component with 'use client' to make it a client component. If we would like to use client side features in a server side component it will throw us an error.

The solution is to move our interactive code into its own client side component.

<img width="492" alt="image" src="https://github.com/phollaki/nextjs13-pocketbase/assets/60651308/2ad80088-f5fd-4ee3-9c0e-2a21895b00c2">

<img width="595" alt="image" src="https://github.com/phollaki/nextjs13-pocketbase/assets/60651308/89469ff2-b20f-4354-a9df-c253288a53db">

<img width="486" alt="image" src="https://github.com/phollaki/nextjs13-pocketbase/assets/60651308/99609152-4ebe-4e0f-9fbe-6a91b116e27f">

Nextjs automatically try to cache all pages by analyzing our data fetching code.

To change this behaviour we can change the dynamic option from 'auto' to 'force-dynamic'.

```js
// export const dynamic = 'auto'
export const dynamic = 'force-dynamic'
// export const dynamic = 'force-static'

export default function Home(){
  return (
    <main>
    </main>
  )
}
```

It will behave like GetServerSideProps (SSR) that always use SSR without caching. Thats good for pages that rely on data that changes very often.

OR

to force-static which will tell to cache the page in definitly. That would be ideal for a page where data never changes. 


There is also a revalidate option that allows to set certain time to revalidate and refetch the page, then it can be cached until the next validation.
```js
export const revalidate = 3000;

export default function Home(){
  return (
    <main>
    </main>
  )
}
```

Its good to know these options, but most of the times the best to let nextjs figure out and define it to us.

One other feature is metadata that good for SEO purpouses. This can be done in any pages or layout files in our app directory. 
```js
export const metadata = {
  title: 'Hi Mom',
  description: 'I am the best developer ever!',
}

export default function Home(){
  return (
    <main>
    </main>
  )
}
```

For dynamic metadata, use generateMetadata function that creates our data on the fly:
```js
export async function generateMetadata({params}:any) {
  return {
    title: '...',
  }
}

export default function Home(){
  return (
    <main>
    </main>
  )
}
```


## Data fetching

We don't need to use getServersideProps getStaticProps anymore in nextjs13. The new version of next uses Server side components that can be Async components. It means we can fetch any data in the component from the server, await them and pass down or render it for the user.

```js
export default async function Home(){
  const a = await prisma.getMany();

  const b = await firebase.getDoc();

  const c = await fetch('...');

  return (
    <main>
    </main>
  )
}
```

With this, Not only better developer experiences, but huge performance increase too.
For example, if we have 2 nested layouts in a page each one does its own data fetching. Instead of fetching data 1 by 1 it can fetch them in parralell. Which can dramatically improve the rendering time and time to interactive to a webpage. 
<img width="597" alt="image" src="https://github.com/phollaki/nextjs13-pocketbase/assets/60651308/ede8d2ec-4044-4511-b9b4-7d85bff93394">

Nextjs uses automatic deduping for fetch api, that means it checks all the fetches with the same input. Which means developers don't have to worry making unneccecary fetch calls or network usage. In addition we can add next options to fetch requests like caching behaviours or revalidation.

```js
const a = await fetch('things', {cache: 'force-cache'} // static data
const a = await fetch('things', {cache: 'no-store'} // highly dynamic data
const a = await fetch('things', { revalidate: 420 } // for everything between - number of seconds
```

# Auth JS

Universal opensource authentication system for the web.

Traditionally developers has to store some kind of password hash in the database. Hackers can some time obtain entire database filled with passwords. But worst of all, they are annoying for end user.


Auth js provides tools to implement passwordless strategies for sign in such as:
- Email link sign in
- Oauth
- Own custom logic - phone sms verification

And does so a way it can be run in any server environment, can used with any modern frontend framework and it can connect to any database.

When the user signs in the default behaviour is to generate a jwt token which is stored client side. 
However we can also store them server side in the database too.

To get started install it to next:
```js
npm i next-auth
```
Then add an api route that export our configuration
<img width="911" alt="image" src="https://github.com/phollaki/nextjs13-pocketbase/assets/60651308/9d9f2c69-6b0d-4844-8b86-c5a851b5e4f3">
<img width="641" alt="image" src="https://github.com/phollaki/nextjs13-pocketbase/assets/60651308/95ec51ab-b64c-4708-9eed-8aad21431767">
<img width="803" alt="image" src="https://github.com/phollaki/nextjs13-pocketbase/assets/60651308/9e58da63-346e-49db-883e-4cfbfa43a13b">

Then add a session provider to the root of our application. 
Any child component can take advantage to the useSession hook to listen to updates to a user in real time.
In addition it provides functions like sign in - sign out that can take the user to a dedicated page with the sign in provider.

On server side we can check the auth state with the getServerSession() hook.

# Prisma

An open source tool that makes it fun work with database.

Prisma is like Sequelize an ORM that adresses similar problems but in a different way.
It has its own declarative schema definition language.

Can create schema from Postgres or Sqlite database, then creates type definitions to make data models type safety.

To get started, run 
```js
npx prisma init
```

This creates an .env file where we can add our database url & a prisma directory to define the schema.

If the existing database already has data we can run:
```js
npx prisma db pull
```
So prisma can autogenerate the schema from it. Each table represented with a model keyword.

If we modify our data, sql database can be modified automatically by prisma:
```js
npx prisma init
```
To interact the database with the server we tell prisma to generate the client library.
```js
npx prisma generate
```
